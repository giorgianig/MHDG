!*****************************************
! project: MHDG
! file: Communications.f90
! date: 10/03/2017
! Exchange solution between ghost faces
!*****************************************
MODULE Communications
 USE MPI_OMP
 USE globals
 USE PrintUtils

 CONTAINS
 
 SUBROUTINE init_Com()
 integer,parameter                   :: etq = 100
 integer,dimension(MPI_STATUS_SIZE)  :: stat
 integer                             :: code, req,ierr
 integer                             :: npro,rbuf,lpro,i,nf2sd,ct,ncon
 integer                             :: psd,prv,ifa,fcount
 integer,dimension(MPIvar%glob_size) :: proext,proint,proc
 integer, allocatable                :: faces_ext(:), faces_int(:)
 
 ! Number of processes
 npro = MPIvar%glob_size 
 
 ! Local process
 lpro = MPIvar%glob_id
 
 ! faces and processes to receive
 ALLOCATE(Mesh%pr2rv(Mesh%nghostfaces))
 ALLOCATE(Mesh%fc2rv(Mesh%nghostfaces))
 Mesh%pr2rv = Mesh%ghostpro
 Mesh%fc2rv = 0
 ct = 1
 DO i=1,Mesh%Nfaces
    IF (Mesh%ghostfaces(i).eq.1) THEN
       Mesh%fc2rv(ct) = i
       ct = ct+1
    END IF
 END DO
 ! ***********************************************************
 ! proext contains the number of ghost faces that each process
 ! compute for the local process, proint contains the number of
 ! ghost faces that the local process compute for the other 
 ! processes
 ! ***********************************************************
 proext = 0
 proint = 0
 DO i = 1,Mesh%nghostfaces
   proext(Mesh%ghostpro(i)) = proext(Mesh%ghostpro(i)) + 1
 END DO
 
 DO i = 1,npro
    rbuf = 0
    CALL MPI_Scatter(proext,1,MPI_INTEGER,rbuf,1,MPI_INTEGER,i-1,MPI_COMM_WORLD,code)
    proint(i) = rbuf 
 END DO
 
 ! Number of faces to send
 nf2sd = 0
 DO i=1,npro
   nf2sd = nf2sd+proint(i)
 END DO
 ALLOCATE(Mesh%fc2sd(nf2sd))
 ALLOCATE(Mesh%pr2sd(nf2sd))
 
 ! Connected processes
 ncon = 0
 DO i=1,npro
    IF (proext(i).eq.0 .and. proint(i).eq.0) CYCLE
    ncon=ncon+1
 END DO
 ALLOCATE(Mesh%connpro(ncon))
 Mesh%connpro=0
 proc = 0
 ct = 0
 DO i=1,npro
   IF (proext(i).eq.0 .and. proint(i).eq.0) CYCLE
   IF (proc(i).eq.0) THEN
      ct = ct+1
      Mesh%connpro(ct)=i
      proc(i) = 1   
   END IF
 END DO
! call syncroprint_vector_int(Mesh%connpro)
! stop
 
 ! Communicate to each process the local number of the faces he needs to send, 
 ! and to whom
 fcount = 1
 DO i=1,npro
    
    IF (MPIvar%glob_id.eq.(i-1)) CYCLE
    ! Process to send
    IF (proext(i).eq.0) THEN
       psd = MPI_PROC_NULL
    ELSE
       psd = i-1
    END IF
    ! Process to receive
    IF (proint(i).eq.0) THEN
       prv = MPI_PROC_NULL
    ELSE
       prv = i-1
    END IF
    ALLOCATE(faces_ext(proext(i)))
    ALLOCATE(faces_int(proint(i)))
    faces_ext = 0    
    faces_int = 0
    
    ! prepare the vector with the index of the faces the local 
    ! process need to receive from a connected process
    ct=1
    DO ifa=1,Mesh%nghostfaces
       IF (Mesh%ghostpro(ifa).eq.i) THEN
          faces_ext(ct) = Mesh%ghostLoc(ifa)
          ct = ct+1
       END IF
    END DO
    
    CALL MPI_SEND(faces_ext,proext(i),MPI_INTEGER,psd,etq,MPI_COMM_WORLD,code)
    CALL MPI_RECV(faces_int,proint(i),MPI_INTEGER,prv,etq,MPI_COMM_WORLD,stat,code)
    
    Mesh%fc2sd(fcount:fcount+proint(i)-1)=faces_int
    Mesh%pr2sd(fcount:fcount+proint(i)-1)=i
    fcount = fcount+proint(i)
    
    DEALLOCATE(faces_ext,faces_int)
 END DO
 
! call syncroprint_vector_int(Mesh%fc2sd)
! call MPI_BARRIER(MPI_COMM_WORLD, ierr)
! call syncroprint_vector_int(Mesh%pr2sd)
! call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
! call syncroprint_vector_int(Mesh%fc2rv)
! call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
! stop
END SUBROUTINE init_com
 
 
SUBROUTINE exchangeSol()
 integer,parameter  :: etq = 100
 integer            :: Neq,Nfp,i,j,Fi
 integer            :: ind(Mesh%Nnodesperface*phys%Neq)
 integer            :: nf2sd
 real*8,allocatable :: buffrv(:,:),buffsd(:,:)
 real*8             :: fbufsd(Mesh%Nnodesperface*phys%Neq)
 real*8             :: fbufrv(Mesh%Nnodesperface*phys%Neq)
 integer            :: code,ierr
 integer,allocatable:: req(:),stat(:,:)
 integer            :: perm(1:refEl%Nfacenodes*phys%Neq)
 
 Neq   = phys%Neq
 Nfp   = Mesh%Nnodesperface 
 nf2sd = size(Mesh%fc2sd)
 
 ! Set permutations for ghostfaces that need to be flipped
 CALL set_permutations(Neq*Nfp,Neq,perm)
 
 ALLOCATE(req(nf2sd+Mesh%nghostfaces))
 ALLOCATE(stat(MPI_STATUS_SIZE,nf2sd+Mesh%nghostfaces))
 req = mpi_request_null
 
 ! Allocate buffers
 ALLOCATE(buffrv(Mesh%Nnodesperface*phys%Neq,Mesh%nghostfaces))
 ALLOCATE(buffsd(Mesh%Nnodesperface*phys%Neq,nf2sd))
 buffrv = 0.
 buffsd = 0.
 
 ! Filling the send buffer
 DO i =1,nf2sd
    Fi = Mesh%fc2sd(i)
    ind = (Fi-1)*Neq*Nfp + (/(j,j=1,Neq*Nfp)/)
    buffsd(:,i) = sol%u_tilde(ind) 
 END DO

 ! Receiving
 DO i = 1,Mesh%nghostfaces
    CALL MPI_IRECV(buffrv(:,i),Neq*Nfp,MPI_DOUBLE_PRECISION,Mesh%pr2rv(i)-1,etq,MPI_COMM_WORLD,req(i),code)
 END DO

 ! Sending
 DO i = 1,nf2sd
    CALL MPI_ISEND(buffsd(:,i),Neq*Nfp,MPI_DOUBLE_PRECISION,Mesh%pr2sd(i)-1,etq,MPI_COMM_WORLD,req(Mesh%nghostfaces+i),code)
 END DO
 
 CALL MPI_WAITALL(size(req), req, stat, code)
 
 
! call syncroprint_matrix(buffsd)
! call MPI_BARRIER(MPI_COMM_WORLD, ierr)
! call syncroprint_matrix(buffrv)
! stop



 ! Storing at the right place
 DO i =1,Mesh%nghostfaces
    Fi = Mesh%fc2rv(i)
    ind = (Fi-1)*Neq*Nfp + (/(j,j=1,Neq*Nfp)/)
!    IF (Mesh%ghostflp(i).eq.1) THEN
!       sol%u_tilde(ind) = buffrv(perm,i)
!    ELSE
       sol%u_tilde(ind) = buffrv(:,i)
!    END IF
 END DO
 
 DEALLOCATE(buffrv,buffsd,req,stat)
 
 CONTAINS
 							!*****************************************
							! Set permutations for flipping faces
							!****************************************     
							 SUBROUTINE set_permutations(n,m,perm)
							 integer, intent(IN)  :: n,m
							 integer, intent(OUT) :: perm(:)
							 integer              :: i
							 integer              :: temp(m,n/m),templr(m,n/m)

							 IF (mod(n,m) .ne. 0) then
							    WRITE(6,*) 'Error! n must be a multiple of m'
							    STOP
							 END IF

							 templr = 0
							 temp = reshape((/(i,i=1,n)/),(/m,n/m/))
							 DO i = 1,n/m
							    templr(:,i) = temp(:,n/m-i+1)
							 END DO
							 perm = reshape(templr,(/n/))
							 END SUBROUTINE set_permutations 
							 
END SUBROUTINE exchangeSol

END MODULE


