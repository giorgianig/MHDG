!*****************************************
! project: MHDG
! file: physics.f90
! date: 20/09/2017
! Define the physics of the model
!  ******** N-Gamma-Energy system     ****
!*****************************************
MODULE physics

USE globals
  IMPLICIT NONE
  
  CONTAINS
  
  

  !*******************************************
  ! Convert physical variable to conservative
  ! variables
  !*******************************************
  SUBROUTINE initPhys()
  
   ! number of equation of the problem
   phys%Neq = 3
   
   ! number of physical variables
   phys%npv = 7
   
   ALLOCATE(phys%phyVarNam(phys%npv))
   ALLOCATE(phys%conVarNam(phys%Neq))
   
   ! Set the name of the physical variables
   phys%phyVarNam(1) = "rho" ! density
   phys%phyVarNam(2) = "u"   ! parallel velocity 
   phys%phyVarNam(3) = "E"   ! total energy
   phys%phyVarNam(4) = "p"   ! pressure
   phys%phyVarNam(5) = "T"   ! temperature
   phys%phyVarNam(6) = "Cs"  ! sound speed
   phys%phyVarNam(7) = "M"   ! Mach            
   
   ! Set the name of the conservative variables
   phys%conVarNam(1) = "rho"   ! U1 = rho
   phys%conVarNam(2) = "Gamma" ! U2 = rho*u
   phys%conVarNam(3) = "nE"    ! U3 = rho*E
    
  END SUBROUTINE



  
  !*******************************************
  ! Convert physical variable to conservative
  ! variables
  !*******************************************
  SUBROUTINE phys2cons(up,ua)
  real*8, dimension(:,:),intent(in)  :: up
  real*8, dimension(:,:),intent(out) :: ua
  
  ua(:,1) = up(:,1)
  ua(:,2) = up(:,1)*up(:,2)
  ua(:,3) = up(:,1)*up(:,3)
          
  END SUBROUTINE phys2cons
  
  
  
  
  !*******************************************
  ! Convert conservative variable to physical
  ! variables
  !*******************************************
  SUBROUTINE cons2phys(ua,up)
  real*8, dimension(:,:),intent(in)  :: ua
  real*8, dimension(:,:),intent(out) :: up
  integer :: i
  
  up(:,1) = ua(:,1)
  up(:,2) = ua(:,2)/ua(:,1)
  up(:,3) = ua(:,3)/ua(:,1)
  up(:,4) = 2./(3.*phys%Mref)*(ua(:,3)-0.5*ua(:,2)**2/ua(:,1))
!  DO i=1,size(up,1)
!    IF (up(i,4)<0.) THEN
!      write(6,*) "up(i,4):",up(i,4)
!    ENDIF
!  END DO  
  up(:,5) = 0.5*up(:,4)/up(:,1)
  up(:,6) = sqrt(2*up(:,5)*phys%Mref)
  up(:,7) = up(:,2)/up(:,6)
  
  END SUBROUTINE cons2phys
  
  
  
		!*****************************************
		! Jacobian matrices
		!****************************************     
		 SUBROUTINE jacobianMatrices(U,b,Ax,Ay)
		 real*8, intent(in)  :: U(:),b(:)
		 real*8, intent(out) :: Ax(:,:),Ay(:,:)
		 real*8              :: A(size(Ax,1),size(Ax,2))
			A       = 0.d0
			A(1,2)  = 1.
			A(2,1)  = -2./3.*U(2)**2/U(1)**2
			A(2,2)  = 4./3.*U(2)/U(1)
			A(2,3)  = 2./3.
			A(3,1)  = -5./3.*U(2)*U(3)/U(1)**2+2./3.*U(2)**3/U(1)**3
   A(3,2)  = 5./3.*U(3)/U(1)-U(2)**2/U(1)**2
   A(3,3)  = 5./3.*U(2)/U(1)   
		 Ax = b(1)*A
		 Ay = b(2)*A
		 END SUBROUTINE jacobianMatrices 
  

		!*****************************************
		! Jacobian matrix for face computations
		!****************************************     
		 SUBROUTINE jacobianMatricesFace(U,bn,An)
		 real*8, intent(in)  :: U(:),bn
		 real*8, intent(out) :: An(:,:)
			An       = 0.d0
			An(1,2)  = 1.
			An(2,1)  = -2./3.*U(2)**2/U(1)**2
			An(2,2)  = 4./3.*U(2)/U(1)
			An(2,3)  = 2./3.
			An(3,1)  = -5./3.*U(2)*U(3)/U(1)**2+2./3.*U(2)**3/U(1)**3        
   An(3,2)  = 5./3.*U(3)/U(1)-U(2)**2/U(1)**2
   An(3,3)  = 5./3.*U(2)/U(1)   
		 An = bn*An
		 END SUBROUTINE jacobianMatricesFace 
		 



		!*****************************************
		! Jacobian matrix for the Bohm BC
		!****************************************     	 
   SUBROUTINE jacobianMatricesBohm(U,A)
		 real*8, intent(in)  :: U(:)
		 real*8, intent(out) :: A(:)
		 real*8              :: aux

    A=0.
    aux = 1.+2./3.*(1-phys%Gmbohm)
    A(1) = -aux*U(2)*U(3)/U(1)**2+(1.-phys%Gmbohm)/3.*2.*U(2)**3/U(1)**3
    A(2) =  aux*U(3)/U(1)-(1.-phys%Gmbohm)*U(2)**2/U(1)**2 
    A(3) =  aux*U(2)/U(1)
    END SUBROUTINE jacobianMatricesBohm
																
																		  
		!*****************************************
		! Curvature term matrix
		!****************************************     
		 SUBROUTINE GimpMatrix(U,divb,G)
		 real*8, intent(in)  :: U(:),divb
		 real*8, intent(out) :: G(:,:)

			G       = 0.d0
	  G(2,1) =  1./3.*U(2)**2/U(1)**2
	  G(2,2) = -2./3.*U(2)/U(1)
	  G(2,3) = 2./3.
	  
		 G = divb*G
		 END SUBROUTINE GimpMatrix 
		 
		   
		!*****************************************
		! Jacobian matrices
		!****************************************     
!		 SUBROUTINE jacobianMatricesBound(u,v,nx,ny,Anp,Anm)
!		 USE LinearAlgebra
!		 real*8, intent(in)  :: u,v,nx,ny
!		 real*8, intent(out) :: Anp(1:3,1:3),Anm(1:3,1:3)
!   real*8              :: An(1:3,1:3),Vm(3,3),Dm(3,3),invVm(3,3)               
!   
!			An = 0.d0
!			An(1,2) = nx
!			An(1,3) = ny
!			An(2,1) = phys%a - u**2.d0*nx - u*v*ny
!			An(2,2) = u*2.d0*nx + v*ny
!			An(2,3) = u*ny
!			An(3,1) = (phys%a-v**2)*ny - u*v*nx
!			An(3,2) = v*nx
!			An(3,3) = 2*v*ny + u*nx
!			
!			CALL eig(An,Vm,Dm)
!			CALL invert_matrix(Vm,invVm)
!			Anp = 0.5*(An+matmul(Vm,matmul(abs(Dm),invVm)) )
!			Anm = 0.5*(An-matmul(Vm,matmul(abs(Dm),invVm)))								

!		 END SUBROUTINE jacobianMatricesBound
							 
		!***********************************************************************
		!
		!                          MAGNETIC FIELD
		!
		!***********************************************************************
  SUBROUTINE defineMagneticField(x,y,b,divb,drift)
  real*8, intent(in)      :: x(:),y(:)
  real*8, intent(out)     :: b(:,:),divb(:),drift(:,:)
  real*8                  :: R0,q,r(size(x))
  
  ! Initialization
  b     = 0.
  divb  = 0.
  drift = 0.

				SELECT CASE(switch%testcase)
				  CASE(1)
      ! Cartesian case with div(b)~=0, n = 2+sin(wx*x )*sin(wy*y),  u = cos(wx*x)*cos(wy*y), E = 20+cos(wx*x)*sin(wy*y)    
            b(:,1) = 1./30.*(x-y**2+2)
            b(:,2) = 1./30.*(x*y+y)
            divb(:) = 1./15.+(1./30.)*x				              
      CASE(2)
      ! Axisymmetric case with div(b)~=0, n = 2+sin(wx*x )*sin(wy*y),  u = cos(wx*x)*cos(wy*y), E = 20+cos(wx*x)*sin(wy*y)
            b(:,1) = 1./30.*(x-y**2+2)
            b(:,2) = 1./30.*(x*y+y)
            divb(:) = 1./30.+((1./30.)*x-(1./30.)*y**2+1./15.)/x+1./30.*(x+1) 				              
      CASE(50:59)
         write(6,*) "Error in defineMagneticField: you should not be here!"
         STOP         
				  CASE(60:69)
        
        ! Circular case with limiter
        R0 = geom%R0        
        q  = geom%q
        r  = phys%lscale*sqrt((x-R0/phys%lscale)**2+y**2)
        b(:,1) = -phys%lscale*y/sqrt(R0**2*q**2+(1-q**2)*r**2)
        b(:,2) = phys%lscale*(x-R0/phys%lscale)/sqrt(R0**2*q**2+(1-q**2)*r**2)

        IF (switch%axisym) THEN
            divb(:) = -y/x/sqrt(R0**2*q**2+(1-q**2)*r**2)*phys%lscale
        ELSE
            WRITE(6,*) "Not coded: usually here you should have an axisym simulation"
            STOP
        END IF
        
        IF (switch%driftvel) THEN
           drift(:,2) =  -1./R0*phys%lscale
        END IF
				  CASE DEFAULT
				      WRITE(6,*) "Error! Test case not valid"
				      STOP
				
				END SELECT
				
  END SUBROUTINE defineMagneticField


  SUBROUTINE loadMagneticField()
					USE interpolation
				 USE HDF5
				 USE HDF5_io_module					
					integer        :: i,ierr,ip,jp
					integer(HID_T) :: file_id
					real*8,pointer,dimension(:,:) :: r2D,z2D,flux2D,Br2D,Bz2D,Bphi2D
					real*8,allocatable,dimension(:,:) :: bx,by,bmod,divb,bmodx,bmody,driftx,drifty
					real*8,allocatable,dimension(:)   :: xvec,yvec
					real*8                            :: x,y
				
				 WRITE(6,*) "******* Loading magnetic field *******"
					! Allocate storing space in phys
					ALLOCATE(phys%b(Mesh%Nnodes,Mesh%Ndim))				
					ALLOCATE(phys%divb(Mesh%Nnodes))
					ALLOCATE(phys%drift(Mesh%Nnodes,Mesh%Ndim))
					ALLOCATE(phys%flux2d(Mesh%Nnodes))
				
					! Dimensions of the file storing the magnetic field for West
					ip = 541
					jp = 391
					ALLOCATE(r2D(ip,jp)) 
					ALLOCATE(z2D(ip,jp))
					ALLOCATE(flux2D(ip,jp))
					ALLOCATE(Br2D(ip,jp))
					ALLOCATE(Bz2D(ip,jp))
					ALLOCATE(Bphi2D(ip,jp))
					ALLOCATE(bx(ip,jp))
					ALLOCATE(by(ip,jp))
					ALLOCATE(bmod(ip,jp))
					ALLOCATE(bmodx(ip,jp))
					ALLOCATE(bmody(ip,jp))
					ALLOCATE(divb(ip,jp))
					ALLOCATE(driftx(ip,jp))
					ALLOCATE(drifty(ip,jp))
				
					! Read file
					CALL HDF5_open('WEST_far_465.h5',file_id,IERR)     
					CALL HDF5_array2D_reading(file_id,r2D,'r2D')
					CALL HDF5_array2D_reading(file_id,z2D,'z2D')
					CALL HDF5_array2D_reading(file_id,flux2D,'flux2D')
					CALL HDF5_array2D_reading(file_id,Br2D,'Br2D')
					CALL HDF5_array2D_reading(file_id,Bz2D,'Bz2D')
					CALL HDF5_array2D_reading(file_id,Bphi2D,'Bphi2D')
					CALL HDF5_close(file_id)  
				 
				 ! Apply length scale
				 r2D = r2D/phys%lscale
				 z2D = z2D/phys%lscale
				 
					! Compute b
					bmod = sqrt(Br2D**2+Bz2D**2+Bphi2D**2)
					bx = -Br2D/bmod
					by = -Bz2D/bmod
				
					! Compute divergence of b
					divb = 0.
					IF (switch%axisym) THEN
						! 1/r*(d r*br/dr)+dbz/dz
						  divb(2:ip-1,2:jp-1) = 1./r2D(2:ip-1,2:jp-1)*(r2D(2:ip-1,3:jp)*bx(2:ip-1,3:jp)- &
						                     r2D(2:ip-1,1:jp-2)*bx(2:ip-1,1:jp-2))/(r2D(2:ip-1,3:jp)-  &
						                     r2D(2:ip-1,1:jp-2))+(by(3:ip,2:jp-1)-by(1:ip-2,2:jp-1))/(z2D(3:ip,2:jp-1)-z2D(1:ip-2,2:jp-1))
						  
					ELSE
					! dbr/dr+dbz/dz
						  divb(2:ip-1,2:jp-1) = (bx(2:ip-1,3:jp-1)-bx(2:ip-1,1:jp-2))/(r2D(2:ip-1,3:jp)-r2D(2:ip-1,1:jp-2))+ &
						                       (by(3:ip,2:jp-1)-by(1:ip-2,2:jp-1))/(z2D(3:ip,2:jp-1)-z2D(1:ip-2,2:jp-1))
					END IF
				
						! Compute drift velocity
						driftx = 0.
						drifty = 0.
						IF (switch%driftvel) THEN
								bmodx = (bmod(2:ip-1,3:jp)-bmod(2:ip-1,1:jp-2))/(r2D(2:ip-1,3:jp)-r2D(2:ip-1,1:jp-2))
								bmody = (bmod(3:ip,2:jp-1)-bmod(1:ip-2,2:jp-1))/(z2D(3:ip,2:jp-1)-z2D(1:ip-2,2:jp-1))
								driftx(2:ip-1,2:jp-1) =  -Bphi2D(2:ip-1,2:jp-1)*bmody/bmod(2:ip-1,2:jp-1)**3
								drifty(2:ip-1,2:jp-1) =   Bphi2D(2:ip-1,2:jp-1)*bmodx/bmod(2:ip-1,2:jp-1)**3
		    END IF
		    
						! Interpolate
						ALLOCATE(xvec(jp))
						ALLOCATE(yvec(ip))
						xvec = r2D(1,:)
						yvec = z2D(:,1)
						DO i = 1,Mesh%Nnodes
									x = Mesh%X(i,1)
									y = Mesh%X(i,2)
									phys%b(i,1) = interpolate( ip, yvec,jp, xvec, bx, y,x, 1e-12)
									phys%b(i,2) = interpolate( ip, yvec,jp, xvec, by, y,x, 1e-12)
									phys%divb(i) = interpolate( ip, yvec,jp, xvec, divb, y,x, 1e-12)
									phys%drift(i,1) = interpolate( ip, yvec,jp, xvec,driftx, y,x, 1e-12)
									phys%drift(i,2) = interpolate( ip, yvec,jp, xvec,drifty, y,x, 1e-12)
									phys%flux2D(i) = interpolate( ip, yvec,jp, xvec,flux2D, y,x, 1e-12)
						END DO
		
					! Free memory 
					DEALLOCATE(Br2D,Bz2D,Bphi2D,xvec,yvec)
					DEALLOCATE(r2D,z2D,flux2D,bx,by,bmod,bmodx,bmody,divb,driftx,drifty)    
 
  END SUBROUTINE loadMagneticField

	
	
  SUBROUTINE loadMagneticFieldTemporalEvolution()
				 USE HDF5
				 USE HDF5_io_module					
				 USE MPI_OMP
					integer        :: ierr,k
				 character(LEN=20) :: fname = 'Evolving_equilibrium'
				 character(10)  :: npr,nid,nit
				 character(len=1000) :: fname_complete					
					integer(HID_T) :: file_id
				
				 WRITE(6,*) "******* Loading magnetic field *******"
				 
					! Allocate storing space in phys
					ALLOCATE(phys%Br(Mesh%Nnodes))				
					ALLOCATE(phys%Bz(Mesh%Nnodes))
					ALLOCATE(phys%Bt(Mesh%Nnodes))
					ALLOCATE(phys%flux2d(Mesh%Nnodes))
				
     ! File name
     write(nit, "(i10)") time%it
     nit = trim(adjustl(nit)) 
     k = INDEX(nit, " ") -1
     
					IF (MPIvar%glob_size.GT.1) THEN
					   write(nid,*) MPIvar%glob_id+1
					   write(npr,*) MPIvar%glob_size
					   fname_complete = trim(adjustl(fname))//'_'//trim(adjustl(nid))//'_'//trim(adjustl(npr))//'_'//REPEAT("0", 4 - k)//trim(ADJUSTL(nit))//'.h5'
					ELSE
					   fname_complete = trim(adjustl(fname))//'_'//REPEAT("0", 4 - k)//trim(ADJUSTL(nit))//'.h5'
					END IF 
          	
     write(6,*) 'Magnetic field loaded from file: ', trim(adjustl(fname_complete))
						
					! Read file
					CALL HDF5_open(fname_complete,file_id,IERR)     
					CALL HDF5_array1D_reading(file_id,phys%Br,'Br')
					CALL HDF5_array1D_reading(file_id,phys%Bz,'Bz')
					CALL HDF5_array1D_reading(file_id,phys%Bt,'Bt')
					CALL HDF5_array1D_reading(file_id,phys%flux2D,'flux')
					CALL HDF5_close(file_id)  
				 
  END SUBROUTINE loadMagneticFieldTemporalEvolution	
							 
							 
END MODULE physics
